node {
    def app
    def nigtlyBranch = 'develop'
    def now = new Date()
    def currentDate = now.format("yyMMdd.HHmm", TimeZone.getTimeZone('UTC'))

    stage('Clone repository') {
        /* Let's make sure we have the repository cloned to our workspace */

        checkout([$class: 'GitSCM', branches: [[name: nigtlyBranch ]], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[url: 'https://github.com/miscaandrei/profileAPI.git']]])
    }


    stage("SonarQube QA analysis") {
        withSonarQubeEnv('SonaQube-Server'){
            def gradleTool =  tool "GradleTool"
            def scannerTool = tool "SonarScannerTool"
            
            bat "${gradleTool}/bin/gradle microBundle" //run a gradle task
            bat "${scannerTool}/bin/sonar-scanner -Dsonar.projectKey=profileAPI -Dsonar.sources=src/main/resources,src/main/webapp,src/main/java -Dsonar.java.binaries=. "
        }
    }
    // stage("Quality QA Gate") {
    //     timeout(time: 2, unit: "MINUTES") {
    //         def qg = waitForQualityGate()
    //         if (qg.status != 'OK') {
    //             // error "Pipeline aborted due to quality gate failure: ${qg.status}";
    //             unstable("The SonarQube scan did not pass!")
    //         }
    //     }
    // }

    stage('Build image') {
        /* This builds the actual image; synonymous to
         * docker build on the command line */
        app = docker.build("miscaandrei/apigradle:nightly-${currentDate}", "--build-arg BRANCH=${nigtlyBranch} -f Dockerfile .")
    }

    stage('Push image') {
        /* Finally, we'll push the image with two tags:
         * First, the incremental build number from Jenkins
         * Second, the 'latest' tag.
         * Pushing multiple tags is cheap, as all the layers are reused. */
        docker.withRegistry('https://registry.hub.docker.com', 'dockerhub') {
            app.push("nightly-${currentDate}")
            app.push("nightly-latest")
        }
    }
}
